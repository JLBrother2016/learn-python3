## python3教程入门
[Python菜鸟教程](http://www.runoob.com/python/python-tutorial.html)

#### Python3 基本数据类型
1. 6种基本的数据类型: Number(数字), String(字符串), List(列表), Tuple(元组), Set(集合), Dictionary(字典)
    * 不可变数据(3个)： Number(数字), String(字符串), Tuple(元组)
    * 可变数据(3个): List(列表), Set(集合), Dictionary(字典)
2. List列表 
    - List(列表)是Python中使用最频繁的数据类型, 列表可以完成大多数集合类的数据结构实现; 列表中的数据类型可以不相同, 可以支持数字, 字符串甚至可以包含列表(所谓嵌套)
    - 列表是写在方括号`[]`之间, 用逗号分隔开的元素列表
    - 和字符一样, 列表可以被索引和截断, 列表被截断后返回一个包含所需元素的新列表
    - 和字符串不一样的是, 列表中的元素可以改变
    - List内置了很多方法, 比如append(), pop()等
    - 可以用`+`操作符进行拼接, List中的元素是可变的
3. Tuple(元组)
    + 元祖(Tuple)与列表相似, 不同之处在于元组的元素不能被修改，元组写在小括号`()`里面, 元素之间用逗号隔开, 元组中的元素类型也可以不同
    + 元组与字符串类似, 可以被索引且下标从0开始, -1为从末尾开始的位置, 也可以进行截取
    + 其实可以把字符串看作一个特殊的元组
    + 虽然元组(tuple)不可以改变, 但它可以包含可变的对象, 构造0个或1个元素的元组比较特殊，所以有一些额外的语法：
    ```python
    tup1 = ()    #空元组
    tup2 = (20,) #一个元素, 需要在元素后添加逗号
    ```
    + 注意: string, list, tuple都是属于sequence(序列)
4. Set(集合)
    - 集合(set)是一个无序不重复元素的序列
    - 基本功能是进行成员关系测试和删除重复元素, 可以使用`{ }`或者`set()`函数创建集合
    - 注意: 创建一个空集合必须使用`set()`而不是`{ }`, 因为`{ }`是用来创建一个空字典
5. Dictionary(字典)
    + 字典(dictionary)是Python中非常有用的内置数据类型
    + 列表是有序的对象集合, 字典是无序的对象结合; 两者的区别在于: 字典当中的元素是通过键来存取, 而不是通过偏移存取
    + 字典是一种映射类型, 字典用`{}`标识, 它是一个无序的*键(key)：值(value)*对的集合
    + 字典中的键(key)必须使用不可变类型; 在同一个字典中, 键(key)必须是唯一的
    + 构造函数dict()可以直接从键值对序列中构建字典
    + 字典类型也有一些内置函数,比如clear(), keys(), values()等
6. Python数据类型转换
    + 有时候, 我们需要对数据内置的类型进行转换, 数据类型的转换, 只需要将数据类型做为函数名即可

#### Python3解释器
1. 交互式编程
2. 脚本式编程, 脚本第一行必须是`#!/usr/bin/python3`
3. Python的解释器不止一种, 有CPython, IPython, Jython, PyPy等

#### Python3注释
- 确保对模块, 函数, 方法和行内注释使用正确的风格
- Python中的注释有单行注释和多行注释, 单行注释以`#`开头, 多行注释用三个单引号`'''`或者三个双引号`"""`将注释括起来

#### Python3云算符
* Python语言支持一下类型的运算符:
    - 算术运算符
    - 比较(关系)运算符
    - 赋值运算符
    - 逻辑运算符
    - 位运算符
    - 成员运算符
    - 身份运算符
    - 运算符优先级
+ `**=`幂赋值运算符`c **= a`等效于`c = c ** a`
+ `//=`取整数赋值运算符`c //= a`等效于`c = c//a`
+ 逻辑运算符: `and`逻辑与, `or`逻辑或, `not`逻辑非
+ python成员运算符: `in`在指定的序列中找到值返回True, 否则返回False; `not in`如果在指定的序列中没有找到则返回True, 否则返回False.
+ 身份运算符: 身份运算符用于比较两个对象的存储单元
    * `is`是判断两个标识符是不是引用自一个对象, 是引用同一个对象则返回True, 否则返回False
    * `is not`是判断两个标识符是不是引用自不同的对象, 不是返回True, 是返回False
    * `id()`函数用于获取对象内存地址
    * `is`与`==`的区别: `is`是判断两个变量引用对象是否为同一个, `==`用于判断引用变量的值是否相等
+ python运算符优先级中, `**`指数优先级最高
+ Python中的`and`从左到右计算表达式, 若所有的值为真, 则返回最后一个值, 若存在假, 返回第一个假
+ Python没有自增操作, Python不使用++的哲学逻辑: 编译器解析上的简洁与语言本身的简洁
+ Python中变量是以内容为基址, s所以只要你的数字内容是5,不管你起什么名字, 这个变量的ID是相同的, 同时说明了Python中一个变量可以以多个名称访问;这样的设计逻辑决定了python中数字类型的值是不可变的, 因为如果a和b都是5, 当改变了a时, b也会跟着变, 这当然是我们不希望看到的; `a = a + 1` 或 `a += 1`通过`id()`观察可知, id的值变化了, 即a已经是新的名称了. ----- 这个是错误的, 因为在交互式环境中, 编译器有一个小整数池的概念, 会把(-5, 256)间的数预先创建好, 而当a和b超过这个范围的时候, 两个变量就不会指向不同的对象了, 因此地址也会不一样.

#### Python3 数字(Number)
* python数字数据类型用于存储数值, 数据类型是不允许改变的, 这就意味着如果改变了数字数据类型的值, 就将重新分配内存空间
* 三种不同的数值类型: 整型(Int) -- 是long类型, 浮点型(float) -- 可以使用科学计数法表示, 复数(complex) -- 用`a + bj` 或者 `complex(a, b)`表示
* 数学函数
* 随机数函数
* 三角函数
* 数值常量: pi(圆周率), e(自然常数)

#### Python3 列表(List)
* python有6个序列的内置类型, 但最常见的是列表(list)和元组(tuple)
* `['Hi!'] * 4` 表示重复, 输出为: `['Hi!', 'Hi!', 'Hi!', 'Hi!']`
* 列表(list)使用中括号`[ ]`, 元组(tuple)是用小括号`( )`

#### Python3 编程第一步
* `a, b = b, a+b`的计算方式为先计算右边表达式, 然后同时赋值给左边, 等价于`n = b, b = a + b, a = n`
* `end`关键字可以用于将结果输出到同一行, 或者在输出的末尾添加不同的字符
* range()函数, 如果需要遍历数字序列, 可以使用内置range()函数, 它会生成数列, 可以使用range以指定数字开始并指定不同的增量(甚至可以是负数, 有时这也叫做步长)
* 可以结合range()和len()函数来遍历一个序列的索引
* python pass是空语句, 是为了保持程序结构的完整性, pass不做任何事情, 一般用做占位语句
* 内置的enumerate函数进行遍历:
    ```python
    for index, item in enumerate(sequence):
        process(index,item)
    ```

#### Python3 迭代器与生成器
1. 迭代器
    * 迭代器是Python最强大的功能之一, 是访问集合元素的一种方式.
    * 迭代器是可以记住遍历位置的对象.
    * 迭代器对象从集合的第一个元素开始访问, 直到所有的元素被访问完结束, 迭代器只会往前不会后退.
    * 迭代器有两个基本的方法: iter() 和 next()
    * 字符串, 列表或元组对象都可以用于创建迭代器
    * 迭代器对象可以使用常规for语句进行遍历
2. 生成器
    * 在Python中, 使用了yield的函数被称为生成器(generator)
    * 跟普通函数不同的是, 生成器是一个返回迭代器的函数, 只能用于迭代操作, 更简单点理解生成器就是一个迭代器
    * 在调用生成器运行的过程中, 每次遇到yield时函数会暂停并保存当前所有的运行信息, 返回yield的值, 并在执行next()方法时从当前位置继续运行
    * 调用一个生成器函数, 返回的是一个迭代器对象
    
#### Python3 函数
* 函数能够提高应用的模块性, 和代码的重复利用率
```python
def 函数名 (参数列表) :
    函数体
```
* 在python中, 类型属于对象, 变量是没有类型的
```python
a = [1, 2, 3]  #[1, 2, 3]是list类型, 而变量a是没有类型, 它仅仅是一个对象的引用(一个指针), 可以是指向List类型对象, 也可以是指向String对象
```
* 可更改(mutable)与不可更改(immutable)对象
    - 在Python中, string, tuple 和 number是不可更改的对象, 而List, dict等则是可以修改的对象
    - 不可变类型: 变量赋值`a = 5`后再赋值`a = 10`, 这里实际是新生成一个int值对象10, 再让a指向它,而5被丢弃, 不是改变a的值, 相当于新生成了a
    - 可变类型: 变量赋值`la = [1, 2, 3, 4]`后再赋值`la[2] = 5`则是将`list la`的第三个元素值更改, 本身la没有动, 只是其内部的一部分值被修改了
    - Python 函数的参数传递:
        + 不可变类型: 类似c++的值传递, 如整数、字符串、元组; 如fun(a), 传递的只是a的值, 没有影响a对象本身; 如果在fun(a)内部修改a的值, 只是修改另一个复制的对象, 不会影响a本身
        + 可变类型: 类似c++的引用传递, 如列表, 字典; 如fun(la), 则是将la真正的传过去, 修改后fun外部的la也会受影响
        + Python中一切都是对象, 严格意义讲我们不能直接说值传递还是引用传递, 我们应该说传递的是不可变对象和传递可变对象.
* 函数的参数
    - 调用函数时可以使用正式参数类型:
        + 必需参数: 须以正确的顺序传入函数, 调用时的数量必需和声明时的一样
        + 关键字参数: 使用关键字参数允许函数调用时参数的顺序与声明时不一致, 因为Python解释器能够用参数名匹配参数值
        + 默认参数: 调用函数时, 如果没有传递参数, 则会使用默认参数
        + 不定长参数: 加了星号`*`的参数会以元组(tuple)的形式导入, 存放所有未命名的变量参数
        + 加两个星号`**`的参数会以字典的形式导入
        + 如果单独出现星号`*`后的参数必须用关键字传入
* 匿名函数
    - python 使用`lambda`来创建匿名函数
    - 所谓匿名, 意思就是不再使用def语句这样标准的形式定义一个函数
        + `lambda`只是一个表达式, 函数体比def简单很多
        + `lambda`的主体是一个表达式, 而不是一个代码块, 仅仅能在lambda表达式中封装有限的逻辑进去
        + `lambda`函数拥有自己的命名空间, 而且不能访问自己参数列表之外或全局命名空间里的参数
        + 虽然`lambda`函数看起来只能写一行, 却不等同于C或C++的内联函数, 后者的目的是调用小函数时不占用函数的栈帧, 从而增加运行效率
    - `lambda` 函数的语法只包含一个语句, 如下: `lambda [arg1 [, arg2, ... argn]] : expression`
    ```python
    sum = lambda arg1, arg2 : arg1 + arg2
    ```
* return 语句
    - return语句用于退出函数, 选择性地向调用方返回一个表达式, 不带参数值的return语句返回None
* 变量作用域
    - python中, 程序的变量并不是在那个位置都可以访问的, 访问的权限决定于这个变量是在哪里赋值的
    - 变量的作用域决定了在哪一部分程序可以访问那个特定的变量名称, python的作用域一共有4种, 分别是:
        + L(Local) 局部作用域
        + E(Enclosing) 闭包函数外的函数中
        + G(Global) 全局作用域
        + B(Built-in) 内建作用域
    - 以`L->E->G->B`的规则查找, 即: 在局部找不到, 便会去局部外的局部找(例如闭包), 再找不到就会去全局找, 再者去内建中去找, 例子:
    ```python
    x = int(2.9)  # 内建作用域
    g_count = 0  # 全局作用域
    def outer():
        o_count = 1  # 闭包函数外的函数中
        def inner():
            i_count = 2  # 局部作用域

    ```
    - python 中只有模块(module), 类(class), 以及函数(def, lambda)才会引入新的作用域, 其他的代码块(如 if/elif/else, try/except, for/while等)是不会引入新的作用域的, 也就是说这些语句内定义的变量, 外部也可以访问
    - 实例中 msg 变量定义在if语句块中, 但外部还是可以访问; 如果将 msg 定义在函数中, 则它就是局部变量, 外部不能访问
* 全局变量和局部变量
    - 定义在函数内部的变量拥有一个局部作用域, 定义在函数外的拥有全局作用域
    - 局部变量只能在其被声明的函数内部访问, 而全局变量可以在整个程序范围内访问
    - 调用函数时, 所有在函数内声明的变量名称都将被加入到作用域中
* global 和 nonlocal关键字
    - 当内部作用域想修改外部作用域的变量时, 就要用到global(全局变量)和nonlocal(外层非全局作用域)关键字

#### python3 数据结构
1. 列表
    * python 中列表是可变的, 这是它区别与字符串和元组的最重要的特点, 一句话概括:列表可以修改, 而字符串和元组不能修改
    * [内部函数的使用链接](http://www.runoob.com/python3/python3-data-structure.html)
    * 将列表当做堆栈使用
    * 将列表当做队列使用
    * 列表推导式, 列表推导式提供了从序列创建列表的最简单途径; 通常应用程序将一些操作应用于某个序列的每个元素, 用其获得结果作为生成新列表的元素, 或者根据确定的判定条件创建子序列
    * 每个序列推导式都在for之后跟一个表达式, 然后有零到多个for或if子句;返回结果是一个根据表达从其后的for和if上下文环境中生成出来的列表;
    * 如果希望表达式推导出一个元组, 就必须使用括号
    * 嵌套列表解析
    * del语句, 使用del语句可以从一个列表中根据索引而不是值来删除一个元素, 这与pop()返回一个值不同, 可以用del语句从列表中删除一个切割, 或清空整个列表(以前的方法是给该切割赋一个空列表)
2. 元组由若干逗号分隔的值组成, 元组在输出时总是有括号的, 以便于正确表达嵌套结构, 在输入是可能有或没有括号, 不过括号通常是必须的(如果元组是更大的表达式的一部分)
3. 集合是一个无序不重复元素的集, 基本功能包括关系测试和消除重复元素；用大括号`{ }`创建集合, 但创建一个空集合必须用`set()` ---- 集合也支持推导式
4. 字典
    * 另一个非常有用的python内建数据类型是字典
    * 序列是以连续的整数为索引, 与此不同的是, 字典是以关键值为索引, 关键字可以是任意不可变类型, 通常用字符串或数值
    * 理解字典的最佳方式是把它看做无序的`键=>值`对集合
    * 在同一个字典之内, 关键字必须是互不相同的
    * 用大括号`{ }` 创建一个空的字典
    * 构造函数dict()直接从键值对元组列表中构建字典
    * 如果有固定的模式, 列表推导式指定特定的键值对
    * 此外, 字典推导可以用来创建任意键和值的表达式词典
    * 如果关键字只是简单的字符串, 使用关键字参数指定键值对有时候更方便

#### Python3 模块
* 把一些定义存放在文件中, 为一些脚本或者交互式的解释器实例使用, 这个文件被称为模块.
* 模块是一个包含所有定义的函数和变量的文件, 其后缀名为`.py`
* 模块可以被别的程序引入, 以使用该模块中的函数等功能, 这也是使用python标准库的方法
* import语句
    - 想使用python源文件, 只需在另一个源文件中执行`import`语句
    - 当解释器遇到`import`语句, 如果模块在当前的搜索路径就会被导入
    - 搜索路径是一个解释器会先进行搜索的所有目录的列表
    - 如果想要导入模块, 需要把命令放在脚本的顶端
    - 一个模块只会被导入一次, 不管执行了多少次import, 这样可以防止导入模块被一遍又一遍地执行
    - 搜索路径是在Python编译或安装的时候确定的, 安装新的库用该也会修改
    - sys.path 输出是一个列表，其中第一项是空串''，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录），亦即我们执行python解释器的目录（对于脚本的话就是运行的脚本所在的目录）。
    - 因此若像我一样在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉。了解了搜索路径的概念，就可以在脚本中修改sys.path来引入一些不在搜索路径中的模块
* from ... import 语句
    - python 的from语句可以从模块中导入一个指定的部分到当前命名空间中
    ```python
    from fibo import fib, fib2 #这个声明不会把整个fibo模块导入到当前的命名空间中，它只会将fibo里的fib函数引入进来
    ```
* 深入模块
    - 模块除了方法定义，还可以包括可执行的代码。这些代码一般用来初始化这个模块。这些代码只有在第一次被导入时才会被执行。
    - 每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用
    - `from fibo import *` -- 所有的名字都导入进来，但是那些由单一下划线（_）开头的名字不在此例
* __name__属性
    - 一个模块被另一个模块引入时, 其主程序将运行, 如果我们想在模块被引入时, 模块中的某一程序块不执行
    - 我们可以用__name__属性来使该程序块仅在该模块自身运行时执行
    - **说明**: 每个模块都有一个__name__属性, 当其值是`__main__`时, 表明该模块自身在运行, 否则是被引入
* dir()函数
    - 内置函数`dir()`可以找到模块内定义的所有名称, 并以一个字符串列表的形式返回
* 标准模块
    - python本身带着一些标准的模块库, 在python库参考文档中将会介绍到
    - 有些模块直接被构建在解析器里, 这些虽然不是语言内置功能, 但是他却能很高效的使用, 甚至是系统级调用也是没有问题的 --- 因为会根据不同的操作系统进行不同的配置
* 包
    - 包是一种管理python模块命名空间的形式, 采用'点模块名称'; 不用担心不同库之间的模块重名的情况
    - 目录只有包含一个叫做__init__.py的文件才会被认作是一个包, 只要是为了避免一些滥俗名字的影响
    - 这个文件中可以包含一些初始化代码或者为`__all__`变量赋值
    - 主模块的名字永远是'__main__', 一个python应用程序的主模块, 应当总是使用绝对路径引用
    - 包还提供一个额外的属性`__path__`： 这是一个目录列表, 里面每一个包含的目录都有为这个包服务的__init__.py

#### python3 输入和输出
* python 两种输出值的方式: 表达式语句和print()函数
* 第三种方式是使用文件对象的write()方法, 标准输出文件可以用sys.stdout引用
* 如果希望输出的形式更加多样, 可以使用str.format()函数来格式话输出值
* 如果希望输出的值转换为字符串, 可以使用repr()或str()函数来实现
    - str()： 函数返回一个用户易读的表达形式
    - repr()： 产生一个解释器易读的表达形式
* 对一个字符串对象调用rjust()方法: 它可以将字符串靠右, 并在左边填充空格
    - ljust()和center(), 这些方法并不会写任何东西,他们仅仅返回新的字符串
    - 另一个方法zfill(), 它会在数字的左边填充0
* [输入输出的详细教程](http://www.runoob.com/python3/python3-inputoutput.html)
* pickle 模块
    - Python的pickle模块实现了基本的数据序列和反序列化
    - 通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去, 永久存储
    - 通过pickle模块的反序列化操作, 我们能够从文件中创建上一次程序保存的对象
    ```python
    pickle.dump(obj, file, [, protocol])
    x = pickle.load(file)
    ```
* [文件操作的方法](http://www.runoob.com/python3/python3-file-methods.html)
* [OS 文件/目录方法](http://www.runoob.com/python3/python3-os-file-methods.html)

#### Python3 错误和异常
* python有两种错误很容易辨认: 语法错误(解析错)和异常
* 异常: 运行期检测到的错误被称为异常
* 异常处理
* 抛出异常: python使用 raise 语句抛出一个指定的异常, raise唯一的一个参数指定了要被抛出的异常
* [错误和异常](http://www.runoob.com/python3/python3-errors-execptions.html)

#### Python3 面向对象
* 面向对象: 类(class), 方法, 类变量, 数据成员, 方法重写, 实例变量, 继承, 实例化, 对象
* [python 面向对象OOB](http://www.runoob.com/python3/python3-class.html)
* 需要注意圆括号中基类的顺序，若是基类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找基类中是否包含方法
* 类的私有属性: `__private_attrs`
* self 代表的是类的实例, self 的名字并不是规定死的，也可以使用 this，但是最好还是按照约定是用 self
* 类专有的方法
* 运算符重载

#### python3 标准库概览
* [标准库概览](http://www.runoob.com/python3/python3-stdlib.html)
* [python3 实例](http://www.runoob.com/python3/python3-examples.html)
